<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Inline async fn - async fn fundamentals initiative</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../index.html">👋 Welcome</a></li><li class="chapter-item "><a href="../../updates.html">✏️ Updates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="../../CHARTER.html">📜 Charter</a></li><li class="chapter-item "><a href="../../stakeholders.html">👪 Stakeholders</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../stakeholders/2021-nov.html">2021-Nov</a></li></ol></li><li class="chapter-item "><a href="../../roadmap.html">🛣 Roadmap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../roadmap/static_async_trait.html">💬 Static async trait</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../roadmap/static_async_trait_mvp.html">MVP: Static async fn in traits</a></li></ol></li><li class="chapter-item "><a href="../../roadmap/impl_trait_in_traits.html">💬 impl Trait in traits</a></li><li class="chapter-item "><a href="../../roadmap/dyn_async_trait.html">💬 Dyn async trait</a></li><li class="chapter-item "><a href="../../roadmap/dyn_trait.html">💤 Dyn trait</a></li><li class="chapter-item "><a href="../../roadmap/async_drop.html">💤 Async drop</a></li><li class="chapter-item "><a href="../../roadmap/async_closures.html">💤 Async closures</a></li></ol></li><li class="chapter-item expanded "><a href="../../evaluation.html">🔬 Evaluation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../evaluation/executor-styles.html">Executor styles</a></li><li class="chapter-item "><a href="../../evaluation/scenarios.html">Reference scenarios</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../evaluation/scenarios/background-logging.html">Background logging</a></li><li class="chapter-item "><a href="../../evaluation/scenarios/implementing-async-read.html">Implementing AsyncRead</a></li></ol></li><li class="chapter-item "><a href="../../evaluation/challenges.html">Challenges</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../evaluation/challenges/bounding_futures.html">Bounding futures</a></li><li class="chapter-item "><a href="../../evaluation/challenges/naming_futures.html">Naming futures</a></li><li class="chapter-item "><a href="../../evaluation/challenges/dyn_traits.html">Dyn traits</a></li><li class="chapter-item "><a href="../../evaluation/challenges/bounding_async_drop.html">Bounding async drop</a></li><li class="chapter-item "><a href="../../evaluation/challenges/guaranteeing_async_drop.html">Guaranteeing async drop</a></li><li class="chapter-item "><a href="../../evaluation/challenges/implicit_await_with_async_drop.html">Implicit await with async drop</a></li></ol></li><li class="chapter-item expanded "><a href="../../evaluation/design.html">Design documents</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../evaluation/design/implied_send.html">Implied Send</a></li><li class="chapter-item "><a href="../../evaluation/design/trait_multiplication.html">Trait multiplication</a></li><li class="chapter-item expanded "><a href="../../evaluation/design/inline_async_fn.html" class="active">Inline async fn</a></li><li class="chapter-item "><a href="../../evaluation/design/custom_dyn_impls.html">Custom dyn impls</a></li><li class="chapter-item "><a href="../../evaluation/design/auto_traits_consider_async_drop.html">Auto traits consider AsyncDrop</a></li><li class="chapter-item "><a href="../../evaluation/design/simple_names.html">Simple names</a></li><li class="chapter-item "><a href="../../evaluation/design/bound_items.html">Bound items</a></li><li class="chapter-item "><a href="../../evaluation/design/with_clauses.html">With clauses</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../explainer.html">📚 Explainer</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../explainer/phase_1.html">Phase 1</a></li><li class="chapter-item "><a href="../../explainer/phase_1_narrative.html">Phase 1 narrative</a></li><li class="chapter-item "><a href="../../explainer/phase_2.html">Phase 2</a></li><li class="chapter-item "><a href="../../explainer/phase_3.html">Phase 3</a></li></ol></li><li class="chapter-item "><a href="../../RFC.html">✨ RFC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../RFC/static_async_fn_in_traits.html">Static async fn in traits</a></li></ol></li><li class="chapter-item "><a href="../../FAQ.html">😕 FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">async fn fundamentals initiative</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/async-fundamentals-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/async-fundamentals-initiative/edit/master/./evaluation/design/inline_async_fn.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="inline-async-fn"><a class="header" href="#inline-async-fn">Inline async fn</a></h1>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>Seems unlikely to be adopted, but may be the seed of a better idea</p>
<h2 id="status-quo"><a class="header" href="#status-quo">Status quo</a></h2>
<p>Until now, the only way to make an &quot;async trait&quot; be dyn-safe was to use a manual poll method. The <a href="https://docs.rs/futures/0.3.15/futures/io/trait.AsyncRead.html"><code>AsyncRead</code></a> trait in futures, for example, is as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AsyncRead {
    fn poll_read(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        buf: &amp;mut [u8]
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;;

    unsafe fn initializer(&amp;self) -&gt; Initializer { ... }
    
    fn poll_read_vectored(
        self: Pin&lt;&amp;mut Self&gt;, 
        cx: &amp;mut Context&lt;'_&gt;, 
        bufs: &amp;mut [IoSliceMut&lt;'_&gt;]
    ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>Implementing these traits is a significant hurdle, as it requires the use of <code>Pin</code>. It also means that people cannot leverage <code>.await</code> syntax or other niceties that they are accustomed to. (See <a href="https://rust-lang.github.io/wg-async-foundations/vision/status_quo/alan_hates_writing_a_stream.html">Alan hates writing a stream</a> for a narrative description.)</p>
<p>It would be nice if we could rework those traits to use <code>async fn</code>. Today that is only possible using the <code>async_trait</code> procedural macro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait AsyncRead {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, Error&gt;;

    async fn poll_read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize, Error&gt;;

    unsafe fn initializer(&amp;self) -&gt; Initializer { ... }
    
}
<span class="boring">}
</span></code></pre></pre>
<p>Unfortunately, using async-trait has some downsides (see <a href="https://rust-lang.github.io/wg-async-foundations/vision/status_quo/alan_needs_async_in_traits.html">Alan needs async in traits</a>). Most notably, the traits are rewritten to return a <code>Box&lt;dyn Future&gt;</code>. For many purposes, this is fine, but in the case of foundational traits like <code>AsyncRead</code>, <code>AsyncDrop</code>, <code>AsyncWrite</code>, it is a significant hurdle:</p>
<ul>
<li>These traits should be included in libcore and available to the no-std ecosystem, like <code>Read</code> and <code>Write</code>.</li>
<li>These traits are often on the performance &quot;hot path&quot; and forcing a memory allocation there could be significant for some applications.</li>
</ul>
<p>There are some other problems with the poll-based design. For example, the buffer supplied to <code>poll_read</code> can change in between invocations (and indeed existing adapters take advantage of this sometimes). This means that the traits cannot be used for <a href="https://github.com/rust-lang/wg-async-foundations/pull/207">zero copy</a>, although this is not the only hurdle.</p>
<h3 id="for-drop-especially-the-state-must-be-embedded-within-the-self-type"><a class="header" href="#for-drop-especially-the-state-must-be-embedded-within-the-self-type">For drop especially, the state must be embedded within the self type</a></h3>
<p>If we want to have an async version of drop, it is really important that it does not return a separate future, but only makes use of state embedded within the type. This is because we might have a <code>Box&lt;dyn Future&gt;</code> or some other type that implements <code>AsyncDrop</code>, but where we don't know the concrete type. We are going to want to be able to drop those, which implies that they will live on the stack, which implies that we have to know the contents of the resulting future to know if it is <code>Send</code>. </p>
<h2 id="problem-returning-a-future"><a class="header" href="#problem-returning-a-future">Problem: returning a future</a></h2>
<p>The fundamental problem that makes <code>async fn</code> not dyn-safe (and the reason that allocation is required) is that every implementation of <code>AsyncRead</code> requires different amounts of state. The future that is returned is basically an enumeration with fields for each value that may be live across an <code>await</code> point, and naturally that will vary per implementation. This means that code which doesn't know the precise type that it is working with cannot predict how much space that type will require. One solution is certainly boxing, which sidesteps the problem by returning a pointer to memory in the heap.</p>
<p>Using poll methods, as the existing traits do, sidesteps this in a different way: the poll methods basically require that any state that the <code>AsyncRead</code> impl requires across invocations of <code>poll</code> must be present within the <code>self</code> field itself. This is a perfectly valid solution for many applications, but figuring out that state and tracking it efficiently is tedious for users.</p>
<h2 id="proposal-inline-futures"><a class="header" href="#proposal-inline-futures">Proposal: &quot;inline&quot; futures</a></h2>
<p>The idea is to allow users to opt-in to &quot;inline futures&quot;. Users would write a <code>repr</code> attribute on traits that contain <code>async fn</code> methods (the attribute):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(inline_async)]
trait AsyncRead {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, Error&gt;;
    
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The choice of <code>repr</code> is significant here:</p>
<ul>
<li>Like repr on a struct, this is meant to be used for things that affect how the code is compiled and its efficiency, but which don't affect the &quot;mental model&quot; of how the trait works.</li>
<li>Like repr on a struct, using repr may imply some limitations on the things you can do with the trait in order to achieve those benefits.</li>
</ul>
<p>When a trait is as <code>repr(inline_async)</code>, the state for all of its async functions will be added into the type that implements the trait (this attribute could potentially also be used per method). This does imply some key limitations:</p>
<ul>
<li><code>repr(inline_async)</code> traits can only be implemented on structs or enums defined in the current crate. This allows the compiler to append those fields into the layout of that struct or enum. </li>
<li><code>repr(inline_async)</code> traits can only contain <code>async fn</code> with <code>&amp;mut self</code> methods.</li>
</ul>
<h2 id="desugaring"><a class="header" href="#desugaring">Desugaring</a></h2>
<p>The desugaring for an <code>inline_async</code> function is different. Rather than an <code>async fn</code> becoming a type that returns an <code>impl Future</code>, the <code>async fn</code> always returns a value of a fixed type. This is a kind of variant on <a href="https://github.com/rust-lang/rust/issues/72302"><code>Future::PollFn</code></a>, which will simply invoke the <code>poll_read</code> function each time it is called. What we want is <em>something</em> like this, although this doesn't quite work (and relies on unstable features Niko doesn't love):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsyncRead {
    // Standard async fn desugaring, with a twist:
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Future::PollFn&lt;
        typeof(&lt;Self as AsyncRead&gt;::poll_read)
    &gt;;

    // 
    fn poll_read(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Basically the <code>read</code> method would</p>
<ul>
<li>initialize the state of the future and then</li>
<li>construct a <a href="https://github.com/rust-lang/rust/issues/72302"><code>Future::PollFn</code></a>-like struct that contains a pointer to the <code>poll_read</code> function. </li>
</ul>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="whats-wrong-with-that-desugaring"><a class="header" href="#whats-wrong-with-that-desugaring">What's wrong with that desugaring?</a></h3>
<p>The desugaring is pretty close. It has the nice property that, when invoked with a known type, the <code>Future::PollFn</code> dispatches statically the poll function, so there is no dynamic dispatch or loss of efficiency.</p>
<p>However, it also has a problem. The return type is still dependent on <code>Self</code>, so per our <em>existing</em> dyn Rules, that doesn't work. </p>
<p>It should be possible to extend our dyn Rules, though. All that is needed is a bit of &quot;adaptation glue&quot; in the code that is included in the vtable so that it will convert from a <code>Future::PollFn</code> for some fixed <code>T</code> to one that uses a <code>fn</code> pointer. That seems eminently doable, but I'm not sure if it can be expressed in the language today. </p>
<p>Pursuing this road might lead to a fundamental extension in dyn safety, which would be nice!</p>
<h3 id="what-state-is-added-precisely-to-the-struct"><a class="header" href="#what-state-is-added-precisely-to-the-struct">What state is added precisely to the struct?</a></h3>
<ul>
<li>An integer recording the await point where the future is blocked</li>
<li>Fields for any data that outlives the await</li>
</ul>
<h3 id="what-if-i-dont-want-lots-of-state-added-to-my-struct"><a class="header" href="#what-if-i-dont-want-lots-of-state-added-to-my-struct">What if I don't want lots of state added to my struct?</a></h3>
<p>We could limit the use of variables live across an await.</p>
<h3 id="could-we-extend-this-to-other-traits"><a class="header" href="#could-we-extend-this-to-other-traits">Could we extend this to other traits?</a></h3>
<p>e.g., simulacrum mentioned <code>-&gt; impl Iterator</code> in a (dyn-safe) trait. Seems plausible.</p>
<h3 id="why-do-you-only-permit-mut-self-methods"><a class="header" href="#why-do-you-only-permit-mut-self-methods">Why do you only permit <code>&amp;mut self</code> methods?</a></h3>
<p>Since the state for the future is stored inline in the struct, we can only have one active future at a time. Using <code>&amp;mut self</code> ensures that the poll function is only in use by one future at a time, since that future would be holding an <code>&amp;mut</code> reference to the receiver.</p>
<h3 id="we-would-like-to-implement-asyncread-for-all-mut-impl-asyncread-how-can-we-enable-that"><a class="header" href="#we-would-like-to-implement-asyncread-for-all-mut-impl-asyncread-how-can-we-enable-that">We would like to implement <code>AsyncRead</code> for all <code>&amp;mut impl AsyncRead</code>, how can we enable that?</a></h3>
<p>I think this <em>should</em> be possible. The trick is that the poll function would just dispatch to another poll function. We might be able to support it by detecting the pattern of the <code>async fn</code> directly awaiting something reachable from self and supporting that for arbitrary types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: AsyncRead&gt; AsyncRead for &amp;mut T {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, Error&gt; {
        T::read(self, buf).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Basically this compiles to a <code>poll_read</code> that just tweaks dispatches to another <code>poll_read</code> with some derefs.</p>
<h3 id="can-you-implement-both-asyncread-and-asyncwrite-for-the-same-type-with-this-technique"><a class="header" href="#can-you-implement-both-asyncread-and-asyncwrite-for-the-same-type-with-this-technique">Can you implement both AsyncRead and AsyncWrite for the same type with this technique?</a></h3>
<p>You can, but you can't simultaneously read and write from the same value. You would need a split-like API. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../evaluation/design/trait_multiplication.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../evaluation/design/custom_dyn_impls.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../evaluation/design/trait_multiplication.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../evaluation/design/custom_dyn_impls.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
